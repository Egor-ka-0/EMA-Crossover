Here we look only at the math behind the project. The previous files explain the idea and the logic.
Now we treat it like a math problem: we want to build two lines that summarize the price history and then use them to update our capital.

1. Prices and returns
Let P[0], P[1], P[2], …, P[T] be the closing prices of the asset for each day.
If we want to know how much the price changed from day t-1 to day t in relative terms, we use the simple return:
R[t] = (P[t] - P[t - 1]) / P[t - 1]
If R[t] = 0.03, it means the price increased by 3 percent that day.  
If R[t] = -0.02, it means a decrease of 2 percent.
In the code we usually keep both the prices P[t] and the daily returns R[t]. The prices are needed to build the averages. The returns are needed to update the capital.

2. What kind of "average" do we want
We want to build two lines:
- a fast line that follows the price more closely,
- a slow line that moves smoother and reacts more slowly.
Let us call such a line M[t]. We want M[t] to have these properties:
- it depends more on recent prices and less on very old prices,
- it changes smoothly from day to day,
- it can be updated using only the previous value M[t - 1] and the new price P[t].
A simple moving average over the last N days would be

S[t] = (P[t] + P[t-1] + ... + P[t - N + 1]) / N

but it has two drawbacks:
- all N days have the same weight,
- to update S[t] exactly, we have to remember all N prices or handle them in a special way.
For our use it is more convenient to use an exponential moving average.
3. Exponential moving average (EMA)
The idea of EMA is to give the highest weight to the current price, slightly smaller weight to yesterday, even smaller to the day before, and so on, with weights that decay in a geometric way.
We choose a number alpha between 0 and 1. Then we define EMA recursively:

EMA[t] = alpha * P[t] + (1 - alpha) * EMA[t - 1]

This formula says:
- the new EMA is a mix of the current price and the previous EMA,
- alpha controls how much we trust the new price versus the past.
If alpha is close to 1, the EMA reacts very fast to new prices.  
If alpha is small, the EMA moves slowly and behaves like a long average.
This recursive definition is equivalent to a weighted sum of all past prices, where the weights decrease as we go back in time. We do not need to write the full sum in the project. It is enough to understand that the EMA is a smooth version of the price that cares more about recent days.
In practice it is common to choose alpha using a window length N. One standard choice is
alpha = 2 / (N + 1)
This gives an EMA that roughly behaves like a moving average with window N but is easier to update.

4. Fast and slow EMA
In the project we build two EMAs with different window lengths:
- EMA_fast[t] with a smaller N_fast (for example 20),
- EMA_slow[t] with a larger N_slow (for example 50).
We compute them with the same recursive rule:
EMA_fast[t] = alpha_fast * P[t] + (1 - alpha_fast) * EMA_fast[t - 1]  
EMA_slow[t] = alpha_slow * P[t] + (1 - alpha_slow) * EMA_slow[t - 1]
with different alpha values based on N_fast and N_slow.
The fast EMA reacts to new moves sooner. The slow EMA changes later. The crossover between these two lines is what we use for the trading rule, as described in the logic files.

5. Signal and capital update
Now we connect the math of returns and EMAs to the capital.
We define a signal S[t] that tells us if we are in the market on day t:
- S[t] = 1 if we hold the asset,
- S[t] = 0 if we are in cash.
The signal is based on the relation between EMA_fast and EMA_slow. For example:
- if EMA_fast[t] is above EMA_slow[t], we set S[t] = 1,
- if EMA_fast[t] is below EMA_slow[t], we set S[t] = 0.
Details of how exactly we handle the crossing days are described in the logic section. Here we only assume that S[t] is already defined for each day.
Let C[t] be our capital at the end of day t. We start with some initial capital C[0], for example 10 000.
On each day t > 0 we update the capital using the simple return R[t] and the signal S[t - 1]:
- if we were invested during day t, the capital changes with the market,
- if we were in cash, the capital stays the same.
Mathematically:

C[t] = C[t - 1] * (1 + S[t - 1] * R[t])

If S[t - 1] = 1, then C[t] = C[t - 1] * (1 + R[t]) and we fully follow the day’s move.  
If S[t - 1] = 0, then C[t] = C[t - 1] and nothing changes.

This recursion is the core of the backtest. Given the price series P[t], we compute returns R[t]. 
Given the returns and the signal S[t], we compute the capital path C[t]. 
All detailed formulas for risk measures like drawdown or volatility can be added on top of this, but the main math of the project is in these steps.
